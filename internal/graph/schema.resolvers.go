package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"github.com/kareemmahlees/meta-x/internal/db"
	"github.com/kareemmahlees/meta-x/internal/graph/model"
	"github.com/kareemmahlees/meta-x/lib"
	"github.com/kareemmahlees/meta-x/models"
)

// CreateDatabase is the resolver for the createDatabase field.
func (r *mutationResolver) CreateDatabase(ctx context.Context, name string) (*model.SuccessResponse, error) {
	err := db.CreatePgMysqlDatabase(r.DB, r.Provider, name)
	if err != nil {
		return nil, err
	}
	return &model.SuccessResponse{
		Success: true,
	}, nil
}

// CreateTable is the resolver for the createTable field.
func (r *mutationResolver) CreateTable(ctx context.Context, name string, data []*model.CreateTableData) (*model.CreateTableResponse, error) {
	convertedData := []models.CreateTablePayload{}
	for _, props := range data {
		convertedData = append(convertedData, models.CreateTablePayload{
			ColName:  *props.ColName,
			Type:     *props.Type,
			Nullable: props.Nullable,
			Default:  props.Default,
			Unique:   props.Unique,
		})
	}
	err := db.CreateTable(r.DB, name, convertedData)
	if err != nil {
		return nil, err
	}
	return &model.CreateTableResponse{
		Created: name,
	}, nil
}

// DeleteTable is the resolver for the deleteTable field.
func (r *mutationResolver) DeleteTable(ctx context.Context, name string) (*model.SuccessResponse, error) {
	err := db.DeleteTable(r.DB, name)
	if err != nil {
		return nil, err
	}
	return &model.SuccessResponse{
		Success: true,
	}, nil
}

// AddColumn is the resolver for the addColumn field.
func (r *mutationResolver) AddColumn(ctx context.Context, tableName string, data model.AddUpdateColumnData) (*model.SuccessResponse, error) {
	convertedData := models.AddModifyColumnPayload{
		ColName: *data.ColName,
		Type:    *data.Type,
	}
	err := db.AddColumn(r.DB, tableName, convertedData)
	if err != nil {
		return nil, err
	}
	return &model.SuccessResponse{Success: true}, nil
}

// ModifyColumn is the resolver for the modifyColumn field.
func (r *mutationResolver) ModifyColumn(ctx context.Context, tableName string, data model.AddUpdateColumnData) (*model.SuccessResponse, error) {
	convertedData := models.AddModifyColumnPayload{
		ColName: *data.ColName,
		Type:    *data.Type,
	}
	err := db.UpdateColumn(r.DB, r.Provider, tableName, convertedData)
	if err != nil {
		return nil, err
	}
	return &model.SuccessResponse{Success: true}, nil
}

// DeleteColumn is the resolver for the deleteColumn field.
func (r *mutationResolver) DeleteColumn(ctx context.Context, tableName string, data *model.DeleteColumnData) (*model.SuccessResponse, error) {
	convertedData := models.DeleteColumnPayload{
		ColName: *data.ColName,
	}
	err := db.DeleteColumn(r.DB, tableName, convertedData)
	if err != nil {
		return nil, err
	}
	return &model.SuccessResponse{Success: true}, nil
}

// Databases is the resolver for the databases field.
func (r *queryResolver) Databases(ctx context.Context) ([]*string, error) {
	var dbs []*string
	var err error

	provider := r.Provider
	switch provider {
	case lib.SQLITE3:
		dbs, err = db.ListDatabasesSqlite(r.DB)
	case lib.PSQL:
		dbs, err = db.ListDatabasesPgMySQL(r.DB, lib.PSQL)
	case lib.MYSQL:
		dbs, err = db.ListDatabasesPgMySQL(r.DB, lib.MYSQL)
	}
	if err != nil {
		return nil, err
	}

	return dbs, nil
}

// Tables is the resolver for the tables field.
func (r *queryResolver) Tables(ctx context.Context) ([]*string, error) {
	tables, err := db.ListTables(r.DB, r.Provider)
	if err != nil {
		return nil, err
	}

	return tables, nil
}

// Table is the resolver for the table field.
func (r *queryResolver) Table(ctx context.Context, name *string) ([]*model.TableInfo, error) {
	result, err := db.GetTableInfo(r.DB, *name, r.Provider)
	if err != nil {
		return nil, err
	}
	var tableInfo []*model.TableInfo
	for _, info := range result {
		name := info.Name
		dataType := info.Type
		nullable := info.Nullable
		key := info.Key
		mod := &model.TableInfo{
			Name:     &name,
			Type:     &dataType,
			Nullable: &nullable,
			Key:      &key,
			Default:  info.Default,
		}
		tableInfo = append(tableInfo, mod)
	}
	return tableInfo, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
